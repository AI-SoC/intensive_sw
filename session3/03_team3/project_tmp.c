/**********************************************************************************************************************

\file Cpu0_Main.c
\copyright Copyright (C) Infineon Technologies AG 2019
Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
are agreed, use of this file is subject to following:
Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
Software is furnished to do so, all subject to the following:
The copyright notices in the Software and this entire statement, including the above license grant, this restriction
and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
derivative works of the Software, unless such copies or derivative works are solely in the form of
machine-executable object code generated by a source language processor.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "IfxCcu6_reg.h"
#include "IfxVadc_reg.h"
#include "IfxGtm_reg.h"

// Port registers
#define PC0_BIT_LSB_IDX 3
#define PC1_BIT_LSB_IDX 11
#define PC2_BIT_LSB_IDX 19
#define PC3_BIT_LSB_IDX 27
#define PC5_BIT_LSB_IDX 11
#define PC7_BIT_LSB_IDX 27
#define P0_BIT_LSB_IDX 0
#define P1_BIT_LSB_IDX 1
#define P2_BIT_LSB_IDX 2
#define P3_BIT_LSB_IDX 3
#define P5_BIT_LSB_IDX 5
#define P7_BIT_LSB_IDX 7

// SCU registers
#define LCK_BIT_LSB_IDX             1
#define ENDINIT_BIT_LSB_IDX         0
#define EXIS0_BIT_LSB_IDX           4
#define EXIS1_BIT_LSB_IDX           20
#define FEN0_BIT_LSB_IDX            8
#define REN0_BIT_LSB_IDX            9
#define FEN1_BIT_LSB_IDX            24
#define REN1_BIT_LSB_IDX            25
#define EIEN0_BIT_LSB_IDX           11
#define EIEN1_BIT_LSB_IDX           27
#define INP0_BIT_LSB_IDX            12
#define INP1_BIT_LSB_IDX            28
#define IGP0_BIT_LSB_IDX            14
#define IGP1_BIT_LSB_IDX            30

// SRC registers
#define SRPN_BIT_LSB_IDX 0
#define TOS_BIT_LSB_IDX 11
#define SRE_BIT_LSB_IDX 10

// CCU60 registers
#define DISS_BIT_LSB_IDX 1
#define DISR_BIT_LSB_IDX 0
#define CTM_BIT_LSB_IDX 7
#define T12PRE_BIT_LSB_IDX 3
#define T12CLK_BIT_LSB_IDX 0
#define T12STR_BIT_LSB_IDX 6
#define T12RS_BIT_LSB_IDX 1
#define INPT12_BIT_LSB_IDX 10
#define ENT12PM_BIT_LSB_IDX 7
#define T12SSC_BIT_LSB_IDX 0

// VADC registers
#define DISS_BIT_LSB_IDX 1
#define DISR_BIT_LSB_IDX 0
#define ANONC_BIT_LSB_IDX 0
#define ASEN0_BIT_LSB_IDX 24
#define CSM0_BIT_LSB_IDX 3
#define PRIO0_BIT_LSB_IDX 0
#define CMS_BIT_LSB_IDX 8
#define FLUSH_BIT_LSB_IDX 10
#define TREV_BIT_LSB_IDX 9
#define ENGT_BIT_LSB_IDX 0
#define RESPOS_BIT_LSB_IDX 21
#define RESREG_BIT_LSB_IDX 16
#define ICLSEL_BIT_LSB_IDX 0
#define VF_BIT_LSB_IDX 31
#define RESULT_BIT_LSB_IDX 0
#define ASSCH7_BIT_LSB_IDX 7


// GTM registers
#define DISS_BIT_LSB_IDX        1
#define DISR_BIT_LSB_IDX        0
#define SEL3_BIT_LSB_IDX        6
#define SEL7_BIT_LSB_IDX        14
#define EN_FXCLK_BIT_LSB_IDX    22
#define FXCLK_SEL_BIT_LSB_IDX   0
#define SEL1_BIT_LSB_IDX        2

// GTM - TOM0 registers
#define UPEN_CTRL1_BIT_LSB_IDX  18
#define HOST_TRIG_BIT_LSB_IDX   0
#define ENDIS_CTRL1_BIT_LSB_IDX 2
#define OUTEN_CTRL1_BIT_LSB_IDX 2
#define CLK_SRC_SR_BIT_LSB_IDX  12
#define OSM_BIT_LSB_IDX         26
#define TRIGOUT_BIT_LSB_IDX     24
#define SL_BIT_LSB_IDX          11
#define UPEN_CTRL3_BIT_LSB_IDX      22
#define ENDIS_CTRL3_BIT_LSB_IDX     6
#define OUTEN_CTRL3_BIT_LSB_IDX     6
#define FUPD_CTRL1_BIT_LSB_IDX      2



IfxCpu_syncEvent g_cpuSyncEvent = 0;

void initLED(void);
void initButton(void);
void initERU(void);
void initCCU60(void);
void initRGBLED(void);
void initVADC(void);
void initBuzzer(void);
void VADC_startConversion(void);
unsigned int VADC_readResult(void);
void initCCU60_mode2(void);
void initMotor(void);
void initGTM(void);
void airplane(void);

unsigned int mode_flag = 0; // Check which mode is (0 : boost off , 1 : ACC mode, 2 : Boost on)
unsigned int mode2_cnt = 0;

/* Counting Time for Boost (Mode:2) Handle on/off  */
unsigned int mode2_check_bef = 1;
unsigned int mode2_check_now = 1;
unsigned int poten;



__interrupt(0x0A) __vector_table(0) // Interrupt for checking how long does driver didn't grab a handle
void CCU60_T12_ISR_mode2(void)
{

if (mode_flag == 2)
{
mode2_cnt += 1;
GTM_TOM0_CH11_SR0.U = (6250000 / 220) - 1;
GTM_TOM0_CH11_SR1.U = (3125000 / 220) - 1;
for(unsigned int i = 0; i < 2500000; i++);
GTM_TOM0_CH11_SR0.U = 0;
GTM_TOM0_CH11_SR1.U = 0;
}
}



__interrupt(0x0B) __vector_table(0)  // 위 버튼
void ERU0_ISR(void)
{
    if ((P02_IN.U & (0x1 << P0_BIT_LSB_IDX)) == 0) // 아래 버튼 눌렀을 떄
    {
        P10_OUT.U |= (0x1 << P2_BIT_LSB_IDX);  // 파란색 led 켜기
    }
    else                                            // 아래 버튼 뗏을 떄
    {
        P10_OUT.U &= ~(0x1 << P2_BIT_LSB_IDX);    // 파란색 끄기
        //initVADC();                                 // 포텐시오미터 읽기 준비
        for(unsigned int i = 0; i < 100000; i++);
        VADC_startConversion();
        poten = VADC_readResult();                   // 포텐시오값 읽기

        if (poten >= 3000)
        {
            mode_flag = 2;
            mode2_cnt = 0;
            mode2_check_bef = 1;
            mode2_check_now = 1;
            P02_OUT.U |= (0x1 << P7_BIT_LSB_IDX);   // brake
            initLED();
            initButton();
            initRGBLED();
            P10_OUT.U &= ~(0x1 << P1_BIT_LSB_IDX);  // Turn off the red light
            P10_OUT.U &= ~(0x1 << P2_BIT_LSB_IDX);  // Turn off the blue light
            P02_OUT.U |= ~(0x1 << P7_BIT_LSB_IDX);  // Turn on RGB blue light
            P10_OUT.U &= ~(0x1 << P5_BIT_LSB_IDX);
            P10_OUT.U |= 0x1 << P3_BIT_LSB_IDX;



        }

        else if (poten >= 1000)
        {
            mode_flag = 1;
            GTM_TOM0_CH9_SR0.U = 12500 - 1;
            P10_OUT.U &= ~(0x1 << P1_BIT_LSB_IDX);  // Turn off the red light
            P10_OUT.U &= ~(0x1 << P2_BIT_LSB_IDX);  // Turn off the blue light
            P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);  // Turn on RGB green light
            P10_OUT.U |=  (0x1 << P5_BIT_LSB_IDX);
            P10_OUT.U &= ~(0x1 << P3_BIT_LSB_IDX);
            P02_OUT.U |= (0x1 << P7_BIT_LSB_IDX);   // brake

        }

        else
        {
            airplane();
            mode_flag = 0;
            P02_OUT.U |= (0x1 << P7_BIT_LSB_IDX);   // brake
            initLED();
            initButton();
            initRGBLED();
            P10_OUT.U &= ~(0x1 << P3_BIT_LSB_IDX);
            P10_OUT.U &= ~(0x1 << P1_BIT_LSB_IDX);  // Turn off the red light
            P10_OUT.U &= ~(0x1 << P2_BIT_LSB_IDX);  // Turn off the blue light
            P02_OUT.U |=  (0x1 << P7_BIT_LSB_IDX);  // Turn on RGB red light
            P10_OUT.U &= ~(0x1 << P5_BIT_LSB_IDX);


        }
    }
}

unsigned int cnt = 0;

__interrupt(0x0C) __vector_table(0)     // 아래 버튼
void ERU1_ISR(void)
        {
            if (mode_flag == 0)
            {
                /* Do nothing */
            }

            else if (mode_flag == 1)
            {
                if((P02_IN.U & (0x1 << P1_BIT_LSB_IDX)) == 0){
                    if(cnt %2 == 0){
                        P10_OUT.U &= ~(0x1 << P1_BIT_LSB_IDX);
                        P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);
                        for(int i = 0;i<1000000000;i++);
                        P02_OUT.U |= (0x1 << P7_BIT_LSB_IDX);
                    }
                    else{
                        P10_OUT.U |= 0x1 << P1_BIT_LSB_IDX;     //방향     // 버튼 눌러서 색 바뀌는거랑 (모터 동시에?)
                        P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);
                        for(int i = 0;i<1000000000;i++);
                        P02_OUT.U |= (0x1 << P7_BIT_LSB_IDX);
                    }
                cnt++;
            }
            }

}



int core0_main(void)
{
IfxCpu_enableInterrupts();

/* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
 * Enable the watchdogs and service them periodically if it is required
 */
IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

/* Wait for CPU sync event */
IfxCpu_emitEvent(&g_cpuSyncEvent);
IfxCpu_waitEvent(&g_cpuSyncEvent, 1);



initERU();
initLED();
initRGBLED();
initButton();
initBuzzer();
initGTM();
//initMotor();
initVADC();
initCCU60_mode2();
P02_OUT.U |= (0x1 << P7_BIT_LSB_IDX);   // brake
GTM_TOM0_TGC1_GLB_CTRL.U |= 0x1 << HOST_TRIG_BIT_LSB_IDX;       // trigger update request signal
GTM_TOM0_CH11_SR0.U = 0;
GTM_TOM0_CH11_SR1.U = 0;


while(1)
{
        if (mode_flag == 0)                             // If MODE : 0
            continue;

        else if (mode_flag == 1){                        // If MODE : 1
            P10_OUT.U &= ~(0x1 << P1_BIT_LSB_IDX);
        }

        else                                            // If MODE : 2
        {
            if ((P02_IN.U & (0x1 << P1_BIT_LSB_IDX)) == 0)                      // If driver grab a handle
            {
                mode2_check_bef = mode2_check_now;
                mode2_check_now = 1;
                P10_OUT.U |= (0x1 << P2_BIT_LSB_IDX);   // Turn on the blue light

            }

            else                                        // If driver loss a handle
            {
                mode2_check_bef = mode2_check_now;
                mode2_check_now = 0;

                P10_OUT.U &= ~(0x1 << P2_BIT_LSB_IDX);  // Turn off the blue light
            }


            if (mode2_check_bef == 0 & mode2_check_now == 0)
            {
                /* Not grabbing handle */
                if (mode2_cnt == 10)
                {
                    /* if mode2_cnt has reached to threshhold */
                    CCU60_TCTR4.B.T12RR = 0x1;       // stop CCU60 T12 counter
                    CCU60_TCTR4.B.T12RES = 0x1;    // Reset CCU60 T12 counter

                    GTM_TOM0_CH11_SR0.U = (6250000 / 220) - 1;
                    GTM_TOM0_CH11_SR1.U = (3125000 / 220) - 1;
                    for(unsigned int i = 0; i < 25000000; i++);
                    GTM_TOM0_CH11_SR0.U = 0;
                    GTM_TOM0_CH11_SR1.U = 0;

                    P10_OUT.U |=  0x1 << P1_BIT_LSB_IDX;
                    P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);
                    for(int i = 0;i<100000000;i++);
                    P02_OUT.U |= (0x1 << P7_BIT_LSB_IDX);

                    mode2_cnt = 0;
                    P10_OUT.U &=  ~(0x1 << P1_BIT_LSB_IDX);

                    CCU60_TCTR4.U = 0x1 << T12RS_BIT_LSB_IDX;       // start CCU60 T12 counter
                }

            }

            else if (mode2_check_bef == 1 & mode2_check_now == 0)
            {
                /* Start of not grabbing handle */
                CCU60_TCTR4.U = 0x1 << T12RS_BIT_LSB_IDX;       // start CCU60 T12 counter
            }

            else if ( mode2_check_bef == 0 & mode2_check_now == 1)
            {
                /* Start of grabbing handle */
                mode2_cnt = 0;
                CCU60_TCTR4.B.T12RR = 0x1;       // stop CCU60 T12 counter
            }

            else
            {
                /* Grabbing handle */
                continue;
            }

        }
    }
return (1);

}

void airplane(void)
{
    // 비행기 //
    unsigned int duty[8] = {130, 146, 164, 174, 195, 220, 246, 262};

    //for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;


    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[4]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[4]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;


    for(unsigned int i = 0; i < 20000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;


    for(unsigned int i = 0; i < 20000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;


    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[4]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[4]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;


    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;


    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;


    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;

    for(unsigned int i = 0; i < 2000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[6]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[6]) - 1;


    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[5]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[5]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = (6250000 / duty[4]) - 1;
    GTM_TOM0_CH11_SR1.U = (3125000 / duty[4]) - 1;

    for(unsigned int i = 0; i < 25000000; i++);
    GTM_TOM0_CH11_SR0.U = 0;
    GTM_TOM0_CH11_SR1.U = 0;
}

void initLED(void)
{
    P10_IOCR0.U &= ~(0x1F << PC1_BIT_LSB_IDX);     // reset P10_IOCR0 PC1
    P10_IOCR0.U &= ~(0x1F << PC2_BIT_LSB_IDX);     // reset P10_IOCR0 PC2

    P10_IOCR0.U |= 0x10 << PC1_BIT_LSB_IDX;        // set P10.1 push-pull general output
    P10_IOCR0.U |= 0x10 << PC2_BIT_LSB_IDX;        // set P10.2 push-pull general output
}

void initButton(void)
{
    //Initialize Switch D2 & D3 (p02.0 p02.1)
    P02_IOCR0.U &= ~(0x1F << PC0_BIT_LSB_IDX); // Reset P02_IOCR0 PC0
    P02_IOCR0.U &= ~(0x1F << PC1_BIT_LSB_IDX); // Reset P02_IOCR0 PC1

    P02_IOCR0.U |= 0x02 << PC0_BIT_LSB_IDX; // Set P02.0 general input (pull-up)
    P02_IOCR0.U |= 0x02 << PC1_BIT_LSB_IDX; // Set P02.1 general input (pull-up)

}

void initERU(void)
{
    // ERU setting  (P02.0 -> ERS3 In32  & p02.1 -> ERS2 In21 )
    SCU_EICR1.U &= ~(0x7 << EXIS0_BIT_LSB_IDX); // Reset ERS2
    SCU_EICR1.U &= ~(0x7 << EXIS1_BIT_LSB_IDX); // Reset ERS3

    SCU_EICR1.U |= (0x1  << EXIS0_BIT_LSB_IDX); // Set ERS2 Input x1
    SCU_EICR1.U |= (0x2  << EXIS1_BIT_LSB_IDX); // Set ERS3 Input x2

    SCU_EICR1.U |= 0x1   << FEN0_BIT_LSB_IDX; // Set ERS2 rising & falling edge
    SCU_EICR1.U |= 0x1   << REN0_BIT_LSB_IDX;
    SCU_EICR1.U |= 0x1   << EIEN0_BIT_LSB_IDX;

    SCU_EICR1.U |= 0x1   << FEN1_BIT_LSB_IDX; // Set ERS3 rising & falling edge
    SCU_EICR1.U |= 0x1   << REN1_BIT_LSB_IDX;
    SCU_EICR1.U |= 0x1   << EIEN1_BIT_LSB_IDX;

    SCU_EICR1.U &= ~(0x7 << INP0_BIT_LSB_IDX); // P02.1 Trigger -> OGU channel 0
    SCU_EICR1.U &= ~(0x7 << INP1_BIT_LSB_IDX); // P02.0 Trigger -> OGU channel 1
    SCU_EICR1.U |= 0x1 << INP1_BIT_LSB_IDX;

    SCU_IGCR0.U &= ~(0x3 << IGP0_BIT_LSB_IDX); // OGU0 -> IOUT
    SCU_IGCR0.U |= 0x1   << IGP0_BIT_LSB_IDX;
    SCU_IGCR0.U &= ~(0x3 << IGP1_BIT_LSB_IDX); // OGU1 -> IOUT
    SCU_IGCR0.U |= 0x1   << IGP1_BIT_LSB_IDX;

    // SRC Interrupt setting
    SRC_SCU_SCU_ERU0.U &= ~(0xFF << SRPN_BIT_LSB_IDX); // OGU0 : SCUERU0
    SRC_SCU_SCU_ERU1.U &= ~(0xFF << SRPN_BIT_LSB_IDX); // OGU1 : SCUERU1

    SRC_SCU_SCU_ERU0.U |= 0x0C   << SRPN_BIT_LSB_IDX;
    SRC_SCU_SCU_ERU1.U |= 0x0B   << SRPN_BIT_LSB_IDX;

    SRC_SCU_SCU_ERU0.U &= ~(0x3  << TOS_BIT_LSB_IDX);
    SRC_SCU_SCU_ERU1.U &= ~(0x3  << TOS_BIT_LSB_IDX);

    SRC_SCU_SCU_ERU0.U |= 1      << SRE_BIT_LSB_IDX;
    SRC_SCU_SCU_ERU1.U |= 1      << SRE_BIT_LSB_IDX;
}


void initRGBLED(void)
{
// reset Port IOCR register
P02_IOCR4.U &= ~(0x1F << PC7_BIT_LSB_IDX);
P10_IOCR4.U &= ~(0x1F << PC5_BIT_LSB_IDX);
P10_IOCR0.U &= ~(0x1F << PC3_BIT_LSB_IDX);

// set Port as general purpose output (push-pull)
P02_IOCR4.U |= 0x10 << PC7_BIT_LSB_IDX;
P10_IOCR4.U |= 0x10 << PC5_BIT_LSB_IDX;
P10_IOCR0.U |= 0x10 << PC3_BIT_LSB_IDX;
}


void initBuzzer(void)
{
P02_IOCR0.B.PC3 = 0x11;
}


void initVADC(void)
{
    // Password Access to unlock SCU_WDTSCON0
    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) & ~(1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) != 0);    // wait until unlocked

    // Modify Access to clear ENDINIT
    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) | (1 << LCK_BIT_LSB_IDX)) & ~(1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) == 0);    // wait until locked

    VADC_CLC.U &= ~(1 << DISR_BIT_LSB_IDX);    // enable VADC

    // Password Access to unlock SCU_WDTSCON0
    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) & ~(1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) != 0);    // wait until unlocked

    // Modify Access to set ENDINIT
    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) | (1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) == 0);


    // VADC configurations
    while((VADC_CLC.U & (1 << DISS_BIT_LSB_IDX)) != 0); // wait until VADC module enabled

    VADC_G4_ARBPR.U |= 0x3 << PRIO0_BIT_LSB_IDX;         // highest priority for Request Source 0
    VADC_G4_ARBPR.U &= ~(0x1 << CSM0_BIT_LSB_IDX);       // Wait-for-Start Mode
    VADC_G4_ARBPR.U |= 0x1 << ASEN0_BIT_LSB_IDX;         // Arbitration Source Input 0 Enable

    VADC_G4_QMR0.U &= ~(0x3 << ENGT_BIT_LSB_IDX);
    VADC_G4_QMR0.U |= 0x1 << ENGT_BIT_LSB_IDX;          // enable conversion request
    VADC_G4_QMR0.U |= 0x1 << FLUSH_BIT_LSB_IDX;         // clear ADC queue

    VADC_G4_ARBCFG.U |= 0x3 << ANONC_BIT_LSB_IDX;       // ADC normal operation

    VADC_G4_ICLASS0.U &= ~(0x7 << CMS_BIT_LSB_IDX);     // Class 0 Standard Conversion (12-bit)


    // VADC Group 4 Channel 7 configuration
    VADC_G4_CHCTR7.U |= 0x1 << RESPOS_BIT_LSB_IDX;      // result right-aligned
    VADC_G4_CHCTR7.U &= ~(0xF << RESREG_BIT_LSB_IDX);   // store result @ Result Register G4RES0
    VADC_G4_CHCTR7.U &= ~(0x3 << ICLSEL_BIT_LSB_IDX);   // Class 0

    VADC_G4_CHASS.U |= 0x1 << ASSCH7_BIT_LSB_IDX;
}

void VADC_startConversion(void)
{
    VADC_G4_QINR0.U |= 0x07;                    // no. of Request Channel = 7

    VADC_G4_QMR0.U |= 0x1 << TREV_BIT_LSB_IDX;  // Generate Conversion Start Trigger Event
}

unsigned int VADC_readResult(void)
{
    unsigned int result;

    while( (VADC_G4_RES0.U & (0x1 << VF_BIT_LSB_IDX)) == 0 );   // wait until read available
    result = VADC_G4_RES0.U & (0xFFF << RESULT_BIT_LSB_IDX);    // read ADC value

    return result;
}


void initCCU60_mode2(void)
{
// Password Access to unlock SCU_WDTSCON0
SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) & ~(1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) != 0); // wait until unlocked

// Modify Access to clear ENDINIT
SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) | (1 << LCK_BIT_LSB_IDX)) & ~(1 << ENDINIT_BIT_LSB_IDX);
while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) == 0);    // wait until locked

CCU60_CLC.U &= ~(1 << DISR_BIT_LSB_IDX);    // enable CCY

// Password Access to unlock SCU_WDTSCON0
SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) & ~(1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) != 0);    // wait until unlocked

// Modify Access to set ENDINIT
SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) | (1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) == 0);    // wait until locked


// CCU60 T12 configurations
while((CCU60_CLC.U & (1 << DISS_BIT_LSB_IDX)) != 0);// wait until CCU60 module enabled

CCU60_TCTR0.U &= ~(0x7 << T12CLK_BIT_LSB_IDX);      // f_T12 = f_CCU6 / prescaler
CCU60_TCTR0.U |= 0x2 << T12CLK_BIT_LSB_IDX;         // f_CCU6 = 50 MHz, prescaler = 1024
CCU60_TCTR0.U |= 0x1 << T12PRE_BIT_LSB_IDX;         // f_T12 = 48,828 Hz

CCU60_TCTR0.U &= ~(0x1 << CTM_BIT_LSB_IDX);         // T12 auto reset when period match (PM) occur


CCU60_T12PR.U = (44828*10)-1;                       // PM interrupt freq. = f_T12 / (T12PR + 1)
CCU60_TCTR4.U |= 0x1 << T12STR_BIT_LSB_IDX;         // load T12PR from shadow register

CCU60_T12.U = 0;                                // clear T12 counter register


// CCU60 T12 PM interrupt setting
CCU60_INP.U &= ~(0x3 << INPT12_BIT_LSB_IDX);        // service request output SR0 selected
CCU60_IEN.U |= 0x1 << ENT12PM_BIT_LSB_IDX;          // enable T12 PM interrupt


// SRC setting for CCU60
SRC_CCU6_CCU60_SR0.U &= ~(0xFF << SRPN_BIT_LSB_IDX);
SRC_CCU6_CCU60_SR0.U |= 0x0A << SRPN_BIT_LSB_IDX;   // set priority 0x0C

SRC_CCU6_CCU60_SR0.U &= ~(0x3 << TOS_BIT_LSB_IDX);  // CPU0 service T12 PM interrupt

SRC_CCU6_CCU60_SR0.U |= 0x1 << SRE_BIT_LSB_IDX;     // SR0 enabled
}

void initMotor(void)
{
    P10_IOCR0.U &= ~(0x1F << PC1_BIT_LSB_IDX);
    P02_IOCR0.U &= ~(0x1F << PC1_BIT_LSB_IDX);
    P02_IOCR4.U &= ~(0x1F << PC7_BIT_LSB_IDX);

    P10_IOCR0.U |= 0x10 << PC1_BIT_LSB_IDX;
    P02_IOCR0.U |= 0x11 << PC1_BIT_LSB_IDX;
    P02_IOCR4.U |= 0x10 << PC7_BIT_LSB_IDX;
}

void initGTM(void)
{
    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0XFC) & ~(1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) != 0);

    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0XFC) | (1 << LCK_BIT_LSB_IDX)) & ~(1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) == 0);

    GTM_CLC.U &= ~(1 << DISR_BIT_LSB_IDX); // enable VADC

    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) & ~(1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) != 0);

    SCU_WDTCPU0_CON0.U = ((SCU_WDTCPU0_CON0.U ^ 0xFC) | (1 << LCK_BIT_LSB_IDX)) | (1 << ENDINIT_BIT_LSB_IDX);
    while((SCU_WDTCPU0_CON0.U & (1 << LCK_BIT_LSB_IDX)) == 0);

    while((GTM_CLC.U & (1 << DISS_BIT_LSB_IDX)) != 0);

    GTM_CMU_FXCLK_CTRL.U &= ~(0xF << FXCLK_SEL_BIT_LSB_IDX);
    GTM_CMU_CLK_EN.U |= 0x2 << EN_FXCLK_BIT_LSB_IDX;

    GTM_TOM0_TGC1_GLB_CTRL.B.UPEN_CTRL1 |= 0x2;
    GTM_TOM0_TGC1_ENDIS_CTRL.B.ENDIS_CTRL1 |= 0x2;
    GTM_TOM0_TGC1_OUTEN_CTRL.B.OUTEN_CTRL1 |= 0x2;

    GTM_TOM0_CH9_CTRL.B.SL |= 0x1;
    GTM_TOM0_CH9_CTRL.B.CLK_SRC_SR |= 0x1;

    GTM_TOM0_CH9_SR0.U = 10 - 1;
    GTM_TOM0_CH9_SR1.U = 10 - 1;


    // set GTM TOM0 channel 11 - Buzzer
    GTM_TOM0_TGC1_GLB_CTRL.U |= 0x2 << UPEN_CTRL3_BIT_LSB_IDX;      // TOM0 channel 11 enable
    GTM_TOM0_TGC1_ENDIS_CTRL.U |= 0x2 << ENDIS_CTRL3_BIT_LSB_IDX;   // enable channel 11 on update trigger
    GTM_TOM0_TGC1_OUTEN_CTRL.U |= 0x2 << OUTEN_CTRL3_BIT_LSB_IDX;   // enable channel 11 output on update trigger


    // TOM0 CH11
    GTM_TOM0_CH11_CTRL.U |= 0x1 << SL_BIT_LSB_IDX;                  // high signal level for duty cycle
    GTM_TOM0_CH11_CTRL.U |= 0x1 << CLK_SRC_SR_BIT_LSB_IDX;          // clock source --> CMU_FXCLK(1) = 6250 kHz
    GTM_TOM0_CH11_CTRL.U &= ~(0x0 << OSM_BIT_LSB_IDX);              // continuous mode
    GTM_TOM0_CH11_CTRL.U &= ~(0x0 << TRIGOUT_BIT_LSB_IDX);
    GTM_TOM0_CH11_SR0.U = 12500 - 1;                                // PWM freq. = 6250 kHz / 12500 = 500 Hz (temp)
    GTM_TOM0_CH11_SR1.U = 6250 - 1;                                 // duty cycle = 6250 / 12500 = 50 % (temp)

    // TOUT pin selection
    GTM_TOUTSEL0.U &= ~(0x3 << SEL3_BIT_LSB_IDX);                   // TOUT3  --> TOM0 channel 11
    GTM_TOUTSEL0.U &= ~(0x3 << SEL1_BIT_LSB_IDX);
}



